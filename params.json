{
  "name": "Aaron.GitHub.io",
  "tagline": "aaron's blog",
  "body": "# 线程提高\r\n\r\n#### 1. 线程，进程，程序的区别\r\n   - 程序：指静态的程序，就是存放在硬盘上的可执行代码\r\n   - 进程：正在内存中运行的程序，其包括改程序运行所要的内存空间，CPU执行权等一系列的资源，一个程序可以有多个进程\r\n   - 线程：指程序代码执行的路径，线程在进程中运行，线程是操作系统分配CPU运算时间的最小单位。\r\n\r\n\r\n####2.创建线程的方式\r\n方式一：\r\n```\r\n          Thread thread1 = new Thread(){\r\n             public void run() {\r\n                 while(true){\r\n                     try {\r\n                        Thread. sleep(500);\r\n                    } catch (InterruptedException e) {\r\n                        e.printStackTrace();\r\n                    }\r\n                    System. out.println(Thread.currentThread().getName());\r\n                    System. out.println(this .getName());\r\n                }\r\n            }\r\n        };\r\n        thread1.start();\r\n```\r\n**说明：创建线程类Thread的子类将其加入到线程体系中使本身也成为线程体系中的一部分，其中要覆盖父类的run方法在其中编写自己的线程要执行的任务**\r\n\r\n\r\n\r\n方式二：\r\n```\r\n      Thread thread2 = new Thread(new Runnable() {           \r\n             @Override\r\n             public void run() {\r\n                 while(true ){\r\n                     try {\r\n                        Thread. sleep(500);\r\n                    } catch (InterruptedException e) {\r\n                        e.printStackTrace();\r\n                    }\r\n                    System. out.println(Thread.currentThread().getName());\r\n                     //因为Runnable接口存放的是线程要运行的代码，不是线程对象，所以不能用this.getName();\r\n                     //System.out.println(this.getName());\r\n                }\r\n            }\r\n        });\r\n        \r\n        thread2.start();\r\n```\r\n**说明：通过继承Runnable接口将自己线程要执行的任务放入Runnable接口的run方法中，再调用Thread的Thread(Runnable r)构造函数由线程类对象调用自己编程的run()方法而不是默认的run()方法**\r\n\r\n测试：\r\n```\r\nnew Thread(new Runnable() {            \r\n             @Override\r\n             public void run() {\r\n                 while(true ){\r\n                     try {\r\n                        Thread. sleep(500);\r\n                    } catch (InterruptedException e) {\r\n                        e.printStackTrace();\r\n                    }\r\n                    System. out.println(\"Runnable:\" +Thread.currentThread ().getName());\r\n                }\r\n            }\r\n        }){\r\n             public void run() {\r\n                 while(true ){\r\n                     try {\r\n                        Thread. sleep(500);\r\n                    } catch (InterruptedException e) {\r\n                        e.printStackTrace();\r\n                    }\r\n                    System. out.println(\"Thread:\" +Thread.currentThread ().getName());                 \r\n                }\r\n            }\r\n        }.start();\r\n```\r\n**说明：这里会输出Thread:Thread-2，因为这里是创建了Thread类的子类并重写了其中的run()方法，所以子类的run()方法会调用自己的run()方法而不是父类(Thread)的run()方法，只有当子类中没有run()方法时才会调用父类的run()方法，所以会输出Thread:Thread-2**\r\n\r\n其中，父类(Thread)的run()方法是这样定义的：\r\n\r\n```\r\nprivate Runnable target;\r\n\r\nThread(Runnable r){\r\n     target = r;\r\n}\r\n\r\npublic void run(){\r\n     if(target!=null){\r\n          target.run();\r\n     }\r\n}\r\n\r\n```\r\n\r\n####3.定时器\r\n  - 创建定时器\r\n\r\n```\r\n\t\t//过1s后调用run()\r\n         new Timer().schedule(new TimerTask() {\r\n             @Override\r\n             public void run() {\r\n                System. out.println(\"bombing\" );\r\n            }\r\n        }, 1000);\r\n             \r\n\t\t//隔1s后执行run()以后每隔3s执行run()\r\n\r\n        new Timer().schedule(new TimerTask() {\r\n            \r\n             @Override\r\n             public void run() {\r\n                System. out.println(\"bombing\" );\r\n            }\r\n        }, 1000,3000);\r\n\r\n\t\t//每隔2s和4s轮流执行run()方法\r\n        new Timer().schedule(new MyTask(),2000);\r\n\r\n\r\n        static class MyTask extends TimerTask{\r\n              static boolean flag=true;\r\n              @Override\r\n              public void run() {\r\n                  System. out.println(\"bombing\" );\r\n                   if(flag )\r\n                       new Timer().schedule(new MyTask(), 4000);\r\n                   else\r\n                       new Timer().schedule(new MyTask(), 2000);\r\n                   flag=!flag ;\r\n              }   \r\n          }   \r\n```\r\n\r\n\r\n**说明：当创建一个定时器时就会在指定时间后开创一个新的线程并执行覆盖了TimerTask类中的run()方法**\r\n\r\n\r\n\r\n####4.线程安全的问题\r\n  - 如果有2个以上的线程要访问同一块资源或者代码就会出现线程安全问题，而解决方法之一就是在公有部分加上synchronized(同一锁对象){}关键字，如果一个实例方法或者静态方法是公有部分就在方法声明时加synchronized,但是实例方法的所对象是this，而静态方法的锁对象是类.class(即类的字节码文件对象)\r\n\r\n\r\n练习1：子线程先运行10次，然后主线程运行100次，然后又是子线程运行，如此循环50次\r\n\r\n解答：\r\n\r\n```\r\npublic class ThreadTest1 {\r\n\r\n    public static void main(String[] args) {\r\n         final Business b = new Business();\r\n        Thread thread = new Thread(new Runnable() {\r\n            \r\n             @Override\r\n             public void run() {\r\n                 for(int i=1; i<=50;i ++)\r\n                    b.sub(i);\r\n            }\r\n        }) ;\r\n        thread.start();\r\n         for(int i=1;i<=50;i++){\r\n            b.main(i);\r\n        }\r\n    }\r\n}\r\n\r\nclass Business{\r\n    boolean isSub= true;\r\n    public synchronized void sub(int loop){\r\n         while(!isSub ){\r\n             try {\r\n                 this.wait();\r\n            } catch (InterruptedException e) {\r\n                 // TODO Auto-generated catch block\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n         for(int i=0;i<10;i++){\r\n            System. out.println(\"sub is \" +i+\",in loop of\"+loop);\r\n        }\r\n         isSub= false;\r\n         this.notifyAll();\r\n    }\r\n    \r\n    public synchronized void main(int loop){\r\n         while(isSub ){\r\n             try {\r\n                 this.wait();\r\n            } catch (InterruptedException e) {\r\n                 // TODO Auto-generated catch block\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n         for(int i=0;i<100;i++){\r\n            System. out.println(\"main is \" +i+\",in loop of\"+loop);\r\n        }\r\n         isSub= true;\r\n         this.notifyAll();\r\n    }\r\n}\r\n```\r\n\r\n**说明：\r\n     - 线程等待和唤醒方法(wait(),notifyAll(),notify())只能在synchronized块中调用，且只能由锁对象调用\r\n    - 如果多个代码块要互斥则应该将它们放到一个类中用同一个锁对象\r\n    - 在线程被唤醒时应该再次检查其的运行条件，即用while循环，因为可能线程被唤醒时还是不具备运行条件(即假唤醒)**\r\n\r\n\r\n\r\n练习2：实现数据在单独一个线程范围的所有操作中共享而在线程之间相互独立，即数据与线程绑定\r\n\r\n解答：\r\n方法一：将数据和所在线程存入HashMap中，取出时按照线程为Key取出\r\n```\r\npublic class ThreadTest2 {\r\n\r\n    static int data ;\r\n    static HashMap<Thread,Integer> hashMap = new HashMap<Thread,Integer>();\r\n    public static void main(String[] args) {\r\n         for(int i=0;i<2;i++){\r\n             new Thread(new Runnable() {     \r\n                 @Override\r\n                 public void run() {\r\n                     /*\r\n                    synchronized (ThreadTest2.class) {                   \r\n                        data = new Random().nextInt();\r\n                        hashMap.put(Thread.currentThread(),data);\r\n                        System.out.println(Thread.currentThread()+\"is put data:\"+data);\r\n                        new A().get();\r\n                        new B().get();\r\n                    }\r\n                */\r\n                     //或者\r\n                     int data = new Random().nextInt();\r\n                     hashMap.put(Thread.currentThread(), data);\r\n                    System. out.println(Thread.currentThread()+ \"is put data:\"+data );\r\n                     new A().get();\r\n                     new B().get();\r\n                }\r\n            }).start();\r\n        }       \r\n    }\r\n    \r\n    static class A{\r\n         public void get(){\r\n            System. out.println(Thread.currentThread()+ \"A get\"+hashMap.get(Thread. currentThread()));\r\n           System.out.println(Thread. currentThread()+ \"A get\"+/*hashMap.get(Thread.currentThread())*/data);\r\n        }\r\n    }\r\n    \r\n    static class B{\r\n         public void get(){\r\n            System. out.println(Thread. currentThread()+\"B get\"+hashMap.get(Thread. currentThread()));\r\n            System.out.println(Thread. currentThread()+ \"B get\"+/*hashMap.get(Thread.currentThread())*/data);\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n方法二：用Java提供的ThreadLocal类实现，ThreadLocal类会将存入的数据自动与执行存入数据的线程相关联\r\n```\r\npublic class ThreadLocalTest {\r\n\r\n    //如果要共享的数据有多个可以将其封装成一个对象，然后再将其传入ThreadLocal中，其中ThreadLocal自动会将数据和线程的关联起来\r\n    static ThreadLocal<Data> threadLocal = new ThreadLocal<Data>();\r\n    public static void main(String[] args) {\r\n         for(int i=0;i<2;i++){\r\n             new Thread(new Runnable() {     \r\n                 @Override\r\n                 public void run() {\r\n                         int ran = new Random().nextInt();\r\n                        Data data = new Data();\r\n                        data.setName( \"name\"+ran);\r\n                        data.setAge(ran);\r\n                         threadLocal.set(data);\r\n                        System. out.println(Thread.currentThread()+ \"is put data:\"+\"name:\"+data.getName()+ \"age:\"+data.getAge());\r\n                         new A().get();\r\n                         new B().get();\r\n                }\r\n            }).start();\r\n        }       \r\n    }\r\n    \r\n    static class A{\r\n         public void get(){\r\n            Data d = threadLocal.get();\r\n            System. out.println(Thread.currentThread()+ \"A get name:\"+d.getName()+\"age:\"+d.getAge());\r\n        }\r\n    }\r\n    \r\n    static class B{\r\n         public void get(){\r\n            Data d = threadLocal.get();\r\n            System. out.println(Thread.currentThread()+ \"B get name:\"+d.getName()+\"age:\"+d.getAge());\r\n        }\r\n    }\r\n    \r\n    static class Data{\r\n         private String name ;\r\n         private int age ;\r\n         public String getName() {\r\n             return name ;\r\n        }\r\n         public void setName(String name) {\r\n             this.name = name;\r\n        }\r\n         public int getAge() {\r\n             return age ;\r\n        }\r\n         public void setAge(int age) {\r\n             this.age = age;\r\n        }       \r\n    }\r\n}\r\n\r\n```\r\n方法三：优化方法二\r\n```\r\npublic class ThreadLocalTest2 {\r\n    \r\n    public static void main(String[] args){\r\n         for(int i=0;i<2;i++){\r\n             new Thread(new Runnable() {\r\n                \r\n                 @Override\r\n                 public void run() {\r\n                     int ran = new Random().nextInt();\r\n                    Data data = Data.getInstance();\r\n                    System. out.println(Thread.currentThread()+ \" put data name\"+ran+\" age \"+ran);\r\n                    data.setName( \"name\"+ran);\r\n                    data.setAge(ran);\r\n                     new A().get();\r\n                     new B().get();\r\n                }\r\n            }).start();\r\n        }\r\n    }\r\n    \r\n    static class A{\r\n         public void get(){\r\n            Data data = Data. getInstance();\r\n            System. out.println(Thread.currentThread()+ \" from A name\"+data.getName()+\" age\"+data.getAge());\r\n        }\r\n    }\r\n    \r\n    static class B{\r\n         public void get(){\r\n            Data data = Data. getInstance();\r\n            System. out.println(Thread.currentThread()+ \" from A name\"+data.getName()+\" age\"+data.getAge());\r\n        }\r\n    }\r\n\r\n    static class Data{\r\n         //定义静态的构造函数，不让外界创建Data的实例对象\r\n         private Data(){}\r\n         public static Data getInstance(){\r\n            Data data = threadLocal.get();\r\n             if(data == null ){\r\n                data = new Data();\r\n                 threadLocal.set(data);\r\n                 return data;\r\n            }\r\n             return threadLocal .get();\r\n        }\r\n         private static ThreadLocal<Data> threadLocal = new ThreadLocal<Data>();\r\n        \r\n         private String name ;\r\n         private int age ;\r\n         public String getName() {\r\n             return name ;\r\n        }\r\n         public void setName(String name) {\r\n             this.name = name;\r\n        }\r\n         public int getAge() {\r\n             return age ;\r\n        }\r\n         public void setAge(int age) {\r\n             this.age = age;\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n方法四：可以用Atomic包中的类进行解决\r\n\r\n\r\n\r\n####5.线程池\r\n  - 创建方法\r\n  创建方法一：\r\n      \r\n```\r\n\t  //创建可以同时执行3个线程任务的线程池\r\n      ExecutorService threadPool = Executors.newFixedThreadPool(3);\r\n      //往线程池中添加任务\r\n      threadPool.execute(Runnable r);\r\n```\r\n  - 线程池中用于存放要执行的线程任务，当创建好线程池，设置好可以同时同步执行的线程数和线程池中的任务之后，线程池会自动的创建线程去执行的线程池中的任务，线程池最多只会创建指定好的线程数去执行任务，其他的任务则等待，直到有线程空闲后在执行，直到线程池中的任务全部执行完为止；如果线程池中的任务比可以创建的线程数少，则线程池会创建和任务相同数量的线程去执行任务。\r\n  ii.当线程池中的任务全部被执行完之后，程序会阻塞，必须要将线程池关闭程序才能结束\r\n\r\n\r\n  创建方法二：  \r\n\r\n  \r\n\r\n```\r\n  //创建可以动态生成线程的线程池\r\n      ExecutorService threadPool = Executors.newCachedThreadPool();\r\n```\r\n\r\n- 利用该方式创建的线程池，会根据任务的数量创建线程数，即如果线程池中还有任务但是没有线程空闲该线程池就会创建一个新的线程去执行线程池中的任务，如果执行了一段时间后线程数大于任务数了，如果有线程在指定时间内一直处于空闲状态，线程池就会收回该线程\r\n- 当线程池中的任务全部被执行完之后，程序会阻塞，必须要将线程池关闭程序才能结束\r\n\r\n\r\n  创建方法三：\r\n  ```\r\n         //创建只有一个线程类的线程池\r\n         ExecutorService threadPool = Executors.newSingleThreadExecutor();\r\n ```\r\n- 利用该方式创建的线程池只会创建一个线程来执行线程池中的任务，如果这个线程在中途死亡了则线程池会创建一个新的线程来代替，直到任务全部被执行完毕，新创建的线程会自动增加\r\n- 当线程池中的任务全部被执行完之后，程序会阻塞，必须要将线程池关闭程序才能结束\r\n\r\n （2）shutdown和shutdownNow的区别\r\n- shutdown：会关闭线程池，使线程池不再接受任务，如果还向已关闭的线程池中添加任务会抛出RejectedExecutionException异常，但是已经在线程池中的任务还是会被执行完\r\n- shutdownNow：会关闭线程池，使线程池不再接受任务，且会阻止正在执行的任务\r\n\r\n\r\n （3）用线程池调用定时器线程\r\n     - 可以在线程池中添加具有定时功能的线程，这些线程会在指定时间之后再去执行线程池中的任务\r\n     - 当线程池中的任务全部被执行完之后，程序会阻塞，必须要将线程池关闭程序才能结束\r\n\r\n```\r\n ScheduledExecutorService threadPool = Executors.newScheduledThreadPool(3);\r\n\r\n //该函数会在指定的时间后创建3个线程去执行线程池中的任务\r\n threadPool.schedule(Runnable r,long delay,TimeUnit t)//TimeUnit用于指定时间的单位\r\n \r\n\r\n //该函数会在指定的时间后按指定创建执行线程去执行线程池中的任务\r\n threadPool.scheduleAtFixedRate(Runnable r,long delay,long perid.TimeUnit t)\r\n```\r\n\r\n\r\n\r\n####6.获取线程任务执行后的返回值\r\n  如果线程任务执行后有返回值则可以用Callable和Future进行返回和接收，\r\n     范例：\r\n     \r\n  \r\n\r\n```\r\n   public class CallableAndFutureTest {\r\n\r\n    /**\r\n     * @param args\r\n     * @throws Exception\r\n     * @throws InterruptedException\r\n     */\r\n    public static void main(String[] args) throws InterruptedException, Exception {\r\n        ExecutorService thread = Executors.newFixedThreadPool(3);\r\n        Future<String> future = thread.submit(new Callable<String>(){\r\n\r\n             @Override\r\n             public String call() throws Exception {\r\n                Thread. sleep(2000);\r\n                 return \"hello\" ;\r\n            }\r\n            \r\n        });\r\n        System. out.println(\"等待返回....\" );\r\n        System. out.println(\"返回的结果是\" +future.get());\r\n    }\r\n}\r\n```\r\n\r\n**说明：用submit和execute提交任务的区别就是submit可以有返回值而execute没有**\r\n\r\nCompletionService用于提交一组有返回值的任务\r\n\r\n```\r\n CompletionService<T> completions = new ExecutorCompletionService<T>(thread1);\r\n     其中：泛型T用于指定返回值的类型\r\n\r\n     范例\r\n    ExecutorService thread1 = Executors.newFixedThreadPool(10);\r\n    CompletionService<Integer> completions = new ExecutorCompletionService<Integer>(thread1);\r\n\r\n     for (int i = 0; i < 10; i++) {\r\n         final int value = i;\r\n         completions.submit(new Callable<Integer>() {\r\n\r\n             @Override\r\n             public Integer call() throws Exception {\r\n                Thread. sleep(new Random().nextInt(5000));\r\n                 return value;\r\n            }\r\n\r\n        });\r\n    }\r\n    \r\n    System. out.println(\"等待结果.....\" );\r\n     for(int i=0;i<10;i++){\r\n         //take()方法用于获取最先完成的任务所返回的Future对象\r\n        System. out.println(completions.take().get());\r\n    }\r\n          \r\n```\r\n\r\n####7.用Lock解决线程安全问题\r\n\r\n```\r\n Lock lock = new ReentrantLock()\r\n     synchronized(对象)｛  \r\n          lock.lock();                     \r\n          try{code}    \r\n          finally{lock.unlock;}                                                                \r\n     ｝                                                        \r\n```\r\n\r\n\r\n说明：为了防止在执行代码时出现错误造成锁不能被释放导致其他线程不能执行，所以要将code放入try{}中，同时必须要保证要同步的线程用的是同一把锁(即同一个锁对象)\r\n\r\n\r\n（1）锁分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，写锁与写锁互斥\r\n     创建可读写锁对象\r\n    \r\n   \r\n\r\n```\r\n  ReadWriteLock lock = new ReentrantReadWriteLock();\r\n         获取读锁\r\n         lock.readLock().lock();\r\n         释放读锁\r\n         lock.readLock().unlock();\r\n         获取写锁\r\n         lock.writeLock().lock();\r\n         释放写锁\r\n         lock.readLock().lock();\r\n```\r\n\r\n读锁和写锁的获取与释放必须相对应的出现\r\n\r\n\r\n（2）Condition对象可以用于唤醒和等待线程，相当于是wait()和notify();\r\n```\r\n     创建Condition对象\r\n     Condition condition = lock.newCondition();\r\n     停止线程\r\n     condition.await();\r\n     唤醒线程(必须有其他线程调用该方法才能唤醒由该condition对象停止的线程)\r\n     condition.signal();\r\n```\r\n**说明：Condition对象与wait()和notify()不同之处：可以创建不同的Condition对象用于唤醒指定的线程**\r\n \r\n（3）Semaphore类\r\n     用于控制可以并发执行的线程数，只有获取到Semaphore中的'灯'之后线程才能执行，如果Semaphore中的灯已经没有了，则线程就会进入等待状态在线程执行完之后必须要释放'灯'，如果不释放则其他线程就永远被阻塞不能运行，如果设置成一个线程可以运行就相当于是互斥锁\r\n```\r\n     实例：\r\npublic class ThreadPoolTest {\r\n    public static void main(String[] args) {\r\n         // 定义一个可以同时执行3个线程任务的线程池\r\n        ExecutorService threadPool = Executors.newFixedThreadPool(10);\r\n        \r\n         //定义Semaphore对象，指定可以同时运行的线程数\r\n         final Semaphore semaphore = new Semaphore(3);\r\n        \r\n         //定义Semaphore对象，指定可以同时运行的线程数，等待者获得锁是先到先得\r\n         //final Semaphore semaphore = new Semaphore(3,true);\r\n\r\n\r\n         // 往线程池中添加任务\r\n         for (int task = 0; task < 10; task++) {\r\n             final int j = task;\r\n            \r\n            threadPool.execute((new Runnable() {\r\n\r\n                 @Override\r\n                 public void run() {\r\n                     try {\r\n                         //获取执行权\r\n                        semaphore.acquire();\r\n                    } catch (InterruptedException e) {\r\n                        e.printStackTrace();\r\n                    }\r\n                     for (int i = 0; i < 10; i++) {\r\n                        System. out.println(Thread.currentThread().getName()\r\n                                + \" is loop of \" + i + \" is task of \" + j);                       \r\n                    }\r\n                     //释放执行权以让其他线程可以运行\r\n                    semaphore.release();\r\n                }\r\n            }));\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n（4）CyclicBarrier类\r\n    该类用于统一集合的运行时间，即所有集合必须都执行到同一代码时线程才能继续往下执行，否者则在原地等待\r\n  \r\n   \r\n\r\n```\r\n 创建CyclicBarrier对象,要有3个线程同时到达时线程才能继续往下执行\r\n     CyclicBarrier cb = new CyclicBarrier(3);\r\n     //线程等待代码\r\n     cb.await();\r\n```\r\n\r\n（5）CountDownLatch类\r\n     该类用于设定线程的等待执行时间，即只有CountDownLatch中的计数器减为0时线程才能往下执行。\r\n     \r\n   \r\n\r\n```\r\n  创建CountDownLatch对象\r\n     CountDownLatch cd = new CountDownLatch(初始时间);\r\n     线程等待，直到计数器减为0\r\n     cd.await();\r\n```\r\n\r\n   \r\n（6）Exchanger类\r\n     该类用于在两个线程之间交换数据，要交换数据的两个类必须使用同一Exchanger对象\r\n     \r\n \r\n\r\n```\r\n创建Exchanger对象\r\n Exchanger e = new Exchanger();\r\n //交换数据\r\n e.exchange(数据);\r\n```\r\n\r\n \r\n\r\n说明：如果两个线程到达交换点的时间不同则先到达的线程会进入等待状态直到另外一个线程也到达然后再进行数据的交换，然后继续执行格子的任务   \r\n\r\n\r\n\r\n（7）阻塞队列(ArrayBlockingQueue)\r\n     该类是一个阻塞式队列，其容量是固定的，内部由一个数组支持，当队列中的控件存储满了之后，再往该队列中存储数据根据不同的存储的方法会返回不同的值，有一种是会发生阻塞直到队列有空为止，当要从该队列中取出数据时根据不同的取数据的方法也会出现不同的结果，有一种也是会发生阻塞直到队列中有数据为止。(其他的存取方法看JDK)。存取数据时按照先进先出(FIFO)的方法。\r\n     \r\n  \r\n\r\n```\r\n   创建ArrayBlockingQueue对象\r\n     ArrayBlockingQueue<T> ab = new ArrayBlockingQueue<T>(容量);\r\n     ab.put(数据)//阻塞式\r\n     ab.take()//阻塞式\r\n```\r\n\r\n（8）当在多线程中要操作Set，Map等数据结构时最好使用java.util.concurrent中的Set和Map，因为其中的类都是多线程安全的（后台实现原理就是给一个Set或Map对象的每一个方法上都加上synchrodu.comnized关键字，使其成为互斥的）。\r\n- CopyOnArrayList类允许用迭代器迭代列表中的值时对列表中的值进行修改，且是线程安全的，而普通的ArrayList则不允许。\r\n- HashSet的底层实现其实就是用的HashMap，只不过只是用到了键而不用值。",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}